<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>CompAero.ObliqueShockRelations API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>CompAero.ObliqueShockRelations</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from math import sqrt, nan, pow, radians, sin, cos, atan, tan, asin, degrees, asin
from multiprocessing.sharedctypes import Value
from scipy.optimize import brenth
import matplotlib.pyplot as plt
import numpy as np

from CompAero.NormalShockRelations import NormalShockRelations
from CompAero.internal import (
    GammaNotDefinedError,
    InvalidOptionCombinationError,
    checkValue,
    footer,
    named_header,
    named_subheader,
    seperator,
    to_string,
    ShockType,
)
from CompAero.greek_letters import LowerCaseGreek as lcg

# TODO: Subclassing from the normal shock relations doesnt seem to make as much sense as it used to
# get rid of the subclassing and mach ObliqueShockRelations it&#39;s own class
class ObliqueShockRelations(NormalShockRelations):
    &#34;&#34;&#34; This class is a collective name space for basic calculations regarding Oblique Shock Properties. 
    The constructor of this class can also determine the entire state of the flow given a partial state of the flow 

    Args:
        gamma (float): Ratio of specific heats
        useDegrees (bool, optional): Angles provided to class are in degrees. Output will still be in radians. Defaults to True.
        shockAngle (float, optional): Angle of the oblique shock wave. Defaults to nan.
        wedgeAngle (float, optional): Angle of the wedge that is deflecting the flow. Defaults to nan.
        mn1 (float, optional): Normal component of mach number ahead of the shock. Defaults to nan.
        mn2 (float, optional): Normal component of mach number behind the shock. Defaults to nan.
        mach (float, optional): Mach number ahead of the shock. Defaults to nan.
        p2_p1 (float, optional): Ratio of pressure behind shock wave to ahead of shock wave. Defaults to nan.
        rho2_rho1 (float, optional): Ratio of density behind shock wave to ahead of shock wave. Defaults to nan.
        t2_t1 (float, optional): Ratio of temperature behind shock wave to ahead of shock wave. Defaults to nan.
        po2_po1 (float, optional): Ratio of total pressure to behind shock wave to ahead of shock wave. Defaults to nan.
        po2_p1 (float, optional): Ratio Total pressure behind shock wave to static pressure ahead of shock wave. Defaults to nan.
        m2 (float, optional): mach number behind shock wave. Defaults to nan.
        shockType (ShockType, optional): Describes whether the oblique shock is a Week or Strong shock. Defaults to ShockType.WEAK.

    Raises:
        RuntimeError: If shock wave angle is found to be less than the mach wave angle at
        RuntimeError: If the deflection angle is found to be greater than the max deflection angle for the flow
        GammaNotDefinedError: Raised if Gamma is undefined
        InvalidOptionCombinationError: Raised if an invalid combination of parameters is given and flow state cannot be determined
        
    Valid_Combinations_of_Parameters:
        1: gamma, mach, shock angle\n
        2. gamma, mach, wedge angle\n
        2: gamma, mach normal 1, shock angle \n
        3: gamma, mach behind shock, wedge angle, shock angle\n
        4: gamma, shock angle, wedge angle\n
        5: gamma, P2/P1, shock angle\n
        6: gamma, Rho2/Rho1, shock angle\n
        7: gamma, T2/T1, shock angle\n
        8: gamma, P02/P01, shock angle\n
        9: gamma, P02/P1, shock angle\n
        10: gamma, dwnStrm_mach, shock angle\n
    &#34;&#34;&#34;

    def __init__(
        self,
        gamma: float,
        useDegrees: bool = True,
        shockAngle: float = nan,
        wedgeAngle: float = nan,
        mn1: float = nan,
        mn2: float = nan,
        mach: float = nan,
        p2_p1: float = nan,
        rho2_rho1: float = nan,
        t2_t1: float = nan,
        po2_po1: float = nan,
        po2_p1: float = nan,
        m2: float = nan,
        shockType: ShockType = ShockType.WEAK,
    ) -&gt; None:
        self.useDegrees = useDegrees
        &#34;&#34;&#34; Angles passed to the constructor are in degrees&#34;&#34;&#34;
        self.shockAngle = shockAngle
        &#34;&#34;&#34; Angle Oblique shock&#34;&#34;&#34;
        self.wedgeAngle = wedgeAngle
        &#34;&#34;&#34; Angle of the flow deflection (wedge) angle&#34;&#34;&#34;
        self.machNorm1 = mn1
        &#34;&#34;&#34; The normal component of the mach number ahead the shock wave&#34;&#34;&#34;
        self.machNorm2 = mn2
        &#34;&#34;&#34; The normal component of the mach number behind the shock wave&#34;&#34;&#34;
        self.gamma = gamma
        &#34;&#34;&#34; Ratio of specific heats &#34;&#34;&#34;
        self.mach = mach
        &#34;&#34;&#34; Mach number of the flow &#34;&#34;&#34;
        self.p2_p1 = p2_p1
        &#34;&#34;&#34; Ratio of pressure behind the shock wave to pressure before the shock wave P2/P1 &#34;&#34;&#34;
        self.rho2_rho1 = rho2_rho1
        &#34;&#34;&#34; Ratio of density behind the shock wave to density before the shock wave rho2/rho1 &#34;&#34;&#34;
        self.t2_t1 = t2_t1
        &#34;&#34;&#34; Ratio of temperature behind the shock wave to temperature before the shock wave T2/T1 &#34;&#34;&#34;
        self.po2_po1 = po2_po1
        &#34;&#34;&#34; Ratio of pressure behind the shock wave to pressure before the shock wave P2/P1 &#34;&#34;&#34;
        self.po2_p1 = po2_p1
        &#34;&#34;&#34; Ratio of total pressure behind the shock wave to pressure before the shock wave P02/P1 &#34;&#34;&#34;
        self.mach2 = m2
        &#34;&#34;&#34; Mach number behind the shock wave &#34;&#34;&#34;
        self.shockType: ShockType = shockType
        &#34;&#34;&#34; The type of shock whether it is strong or weak &#34;&#34;&#34;
        self.precision = 4
        &#34;&#34;&#34; Precision to use when printing output to the console defaults to four &#34;&#34;&#34;

        if self.useDegrees and checkValue(self.shockAngle):
            self.shockAngle = radians(self.shockAngle)
        if self.useDegrees and checkValue(self.wedgeAngle):
            self.wedgeAngle = radians(self.wedgeAngle)

        if not checkValue(self.gamma):
            raise GammaNotDefinedError()

        if checkValue([self.mach, self.shockAngle]):
            machWaveAngle = ObliqueShockRelations.calc_mach_wave_angle(self.mach)
            if self.shockAngle &lt; machWaveAngle or self.shockAngle &gt; radians(90):
                raise ValueError(&#34;Shock Angle of [{}] must be between mach wave angle of [{}] and 90 degrees for mach [{}]&#34;.format(degrees(self.shockAngle), degrees(machWaveAngle), self.mach))
        
        elif checkValue([self.mach, self.wedgeAngle]):
            maxShockAngle = ObliqueShockRelations.calc_max_shock_angle(self.mach, self.gamma)
            maxWedgeAngle = ObliqueShockRelations.calc_max_flow_deflection_angle(maxShockAngle, self.mach, self.gamma)
            if self.wedgeAngle &gt; maxWedgeAngle:
                raise ValueError(&#34;Wedge angle of [{}] is greater than a maximum wedge angle of [{}] for mach [{}]&#34;.format(degrees(self.wedgeAngle), degrees(maxWedgeAngle), self.mach))


        elif checkValue(self.machNorm1) and checkValue(self.shockAngle):
            if (self.machNorm1 &lt; 1):
                raise ValueError(&#34;Normal Component of mach ahead of shock wave must be greater than 1&#34;)
            self.mach = ObliqueShockRelations.calc_mach_ahead_shock_from_mach_normal_ahead_shock(
                self.machNorm1, self.shockAngle
            )

        elif checkValue(m2) and checkValue(self.wedgeAngle) and checkValue(self.shockAngle):
            self.machNorm2 = ObliqueShockRelations.calc_mach_normal_behind_shock_from_mach_behind_shock(
                m2, self.shockAngle, self.wedgeAngle
            )
            if self.machNorm2 &gt; 1:
                assert ValueError(&#34;Normal component of downstream mach number has to be less than 1&#34;)
            self.machNorm1 = NormalShockRelations.calc_mach_before_normal_shock_from_mach_after_shock(
                self.machNorm2, self.gamma
            )
            self.mach = ObliqueShockRelations.calc_mach_ahead_shock_from_mach_normal_ahead_shock(
                self.machNorm1, self.shockAngle
            )

        elif checkValue(self.shockAngle) and checkValue(self.wedgeAngle):
            self.mach = ObliqueShockRelations.calc_mach_from_theta_beta_mach(
                self.shockAngle, self.wedgeAngle, self.gamma
            )
            machAngle = ObliqueShockRelations.calc_mach_wave_angle(self.mach)
            maxShockAngle = ObliqueShockRelations.calc_max_shock_angle(self.mach, self.gamma)
            maxDeflectionAngle = ObliqueShockRelations.calc_max_flow_deflection_angle(
                maxShockAngle, self.mach, self.gamma
            )

            if machAngle &gt; self.shockAngle:
                raise RuntimeError(
                    &#34;Shock Angle, {}, cannot be less than that of Mach Wave, {}&#34;.format(
                        round(self.shockAngle, 4), round(machAngle, 4)
                    )
                )

            if maxDeflectionAngle &lt; self.wedgeAngle:
                raise RuntimeError(
                    &#34;SHOCK DETACHED!! Deflection Angles: Given: {}\tMax: {}&#34;.format(
                        round(self.wedgeAngle, 4), round(maxDeflectionAngle, 4)
                    )
                )

        elif checkValue([po2_p1, self.shockAngle]):
            self.machNorm1 = NormalShockRelations.calc_mach_from_po2_p1(po2_p1, self.gamma)
            self.mach = ObliqueShockRelations.calc_mach_ahead_shock_from_mach_normal_ahead_shock(
                self.machNorm1, self.shockAngle
            )

        elif checkValue([p2_p1, self.shockAngle]):
            self.machNorm1 = NormalShockRelations.calc_mach_from_p2_p1(p2_p1, self.gamma)
            self.mach = ObliqueShockRelations.calc_mach_ahead_shock_from_mach_normal_ahead_shock(
                self.machNorm1, self.shockAngle
            )

        elif checkValue([rho2_rho1, self.shockAngle]):
            self.machNorm1 = NormalShockRelations.calc_mach_from_rho2_rho1(rho2_rho1, self.gamma)
            self.mach = ObliqueShockRelations.calc_mach_ahead_shock_from_mach_normal_ahead_shock(
                self.machNorm1, self.shockAngle
            )

        elif checkValue([t2_t1, self.shockAngle]):
            self.machNorm1 = NormalShockRelations.calc_mach_from_T2_T1(t2_t1, self.gamma)
            self.mach = ObliqueShockRelations.calc_mach_ahead_shock_from_mach_normal_ahead_shock(
                self.machNorm1, self.shockAngle
            )

        elif checkValue([po2_po1, self.shockAngle]):
            self.machNorm1 = NormalShockRelations.calc_mach_from_po2_po1(po2_po1, self.gamma)
            self.mach = ObliqueShockRelations.calc_mach_ahead_shock_from_mach_normal_ahead_shock(
                self.machNorm1, self.shockAngle
            )

        elif checkValue(self.machNorm2) and checkValue(self.shockAngle):
            self.machNorm1 = NormalShockRelations.calc_mach_before_normal_shock_from_mach_after_shock(
                self.machNorm2, self.gamma
            )
            self.mach = ObliqueShockRelations.calc_mach_ahead_shock_from_mach_normal_ahead_shock(
                self.machNorm1, self.shockAngle
            )

        else:
            raise InvalidOptionCombinationError()

        if checkValue(self.mach) and ((checkValue(self.shockAngle) or checkValue(self.wedgeAngle))):
            self.__calculateState()

        super().__init__(self.gamma, mach=self.machNorm1)
        self.mach = ObliqueShockRelations.calc_mach_ahead_shock_from_mach_normal_ahead_shock(
            self.machNorm1, self.shockAngle
        )
        self.machNorm2 = self.mach2
        self.mach2 = ObliqueShockRelations.calc_mach_behind_shock(
            self.machNorm2, self.wedgeAngle, self.shockAngle
        )
        
        if self.useDegrees:
            self.wedgeAngle = degrees(self.wedgeAngle)
            self.shockAngle = degrees(self.shockAngle)

    def __calculateState(self) -&gt; None:
        if checkValue(self.wedgeAngle):
            if self.shockType == ShockType.WEAK:
                self.shockAngle = ObliqueShockRelations.calc_beta_from_theta_beta_mach_weak(
                    self.wedgeAngle, self.mach, self.gamma
                )

            elif self.shockType == ShockType.STRONG:
                self.shockAngle = ObliqueShockRelations.calc_beta_from_theta_beta_mach_strong(
                    self.wedgeAngle, self.mach, self.gamma
                )

            else:
                raise ValueError(
                    &#34;Incorrect shock type specified -&gt; [{}]. Choices: Strong, Weak&#34;.format(
                        self.shockType.name
                    )
                )

        elif checkValue(self.shockAngle):
            self.wedgeAngle = ObliqueShockRelations.calc_theta_from_theta_beta_mach(
                self.shockAngle, self.mach, self.gamma
            )

        self.machNorm1 = ObliqueShockRelations.calc_mach_normal_ahead_shock(self.mach, self.shockAngle)

    def __str__(self) -&gt; str:
        return &#34;&#34;.join(
            [
                named_header(&#34;Oblique Shock Relations at Mach&#34;, self.mach, self.precision),
                seperator(),
                named_subheader(&#34;Upstream Conditions&#34;),
                to_string(lcg.gamma, self.gamma, self.precision),
                to_string(&#34;Mach&#34;, self.mach, self.precision, dot_line=True),
                to_string(&#34;Mach Normal Component&#34;, self.machNorm1, self.precision),
                to_string(
                    &#34;Flow Deflection Angle {}&#34;.format(lcg.theta),
                    self.wedgeAngle,
                    self.precision,
                    dot_line=True,
                ),
                to_string(&#34;Shock Angle {}&#34;.format(lcg.beta), self.shockAngle, self.precision),
                to_string(&#34;Flow Turn Type&#34;, self.shockType.name, self.precision),
                seperator(),
                named_subheader(&#34;Shock Jump Conditions&#34;),
                to_string(&#34;P2/P1&#34;, self.p2_p1, self.precision),
                to_string(&#34;{}2/{}1&#34;.format(*[lcg.rho] * 2), self.rho2_rho1, self.precision, dot_line=True),
                to_string(&#34;T2/T1&#34;, self.t2_t1, self.precision),
                to_string(&#34;P02/P01&#34;, self.po2_po1, self.precision, dot_line=True),
                to_string(&#34;P02/P1&#34;, self.po2_p1, self.precision),
                seperator(),
                named_subheader(&#34;Downstream Conditions&#34;),
                to_string(&#34;Mach&#34;, self.mach2, self.precision, dot_line=True),
                to_string(&#34;Mach Normal Component&#34;, self.machNorm2, self.precision),
                footer(),
            ]
        )

    @staticmethod
    def calc_mach_normal_ahead_shock(mach: float, beta: float) -&gt; float:
        &#34;&#34;&#34; Calculates the normal component of the mach number ahead of the shock wave

        Args:
            mach (float): Mach number of flow ahead of shock wave
            beta (float): Angle of oblique shock in radians

        Raises:
            ValueError: Raised if mach number is less than 1.0

        Returns:
            float: Normal component of upstream mach number
        &#34;&#34;&#34;
        if mach &lt; 1.0:
            raise ValueError(&#34;Normal Shocks Require a mach greater than 1&#34;)

        machWave = ObliqueShockRelations.calc_mach_wave_angle(mach)

        if abs(beta - machWave) &lt; 1e-5:
            return 1.0

        if beta &lt; machWave:
            return nan

        return mach * sin(beta)

    @staticmethod
    def calc_mach_ahead_shock_from_mach_normal_ahead_shock(machNormal1: float, beta: float) -&gt; float:
        &#34;&#34;&#34; Calculates the upstream mach number from the normal component of the upstream mach number

        Args:
            machNormal1 (float): Normal Component of mach number ahead of the shock wave
            beta (float): Angle of oblique shock in radians

        Returns:
            float: Returns value of mach number of the flow ahead of the shock wave
        &#34;&#34;&#34;
        return machNormal1 / sin(beta)

    @staticmethod
    def calc_beta_from_mach_mach_normal_ahead_shock(mach: float, machNormal1: float) -&gt; float:
        &#34;&#34;&#34; Calculates the Oblique shock angle from the normal component of the mach number that is ahead of the shock wave

        Args:
            mach (float): Mach number of the flow ahead of the shock wave
            machNormal1 (float): Normal Component of mach number of the flow that is ahead of the oblique shock wave

        Returns:
            float: Oblique Shock Angle
        &#34;&#34;&#34;
        return asin(machNormal1 / mach)

    @staticmethod
    def calc_mach_behind_shock(machNormal2: float, theta: float, beta: float) -&gt; float:
        &#34;&#34;&#34; Calculates the Mach number behind the oblique shock wave

        Args:
            machNormal2 (float): Normal Component of the mach number behind the shock wave
            theta (float): Flow Deflection Angle (radians) (Wedge angle)
            beta (float): Oblique shock angle (radians)

        Returns:
            float: Mach number of flow behind the oblique shock
        &#34;&#34;&#34;
        return machNormal2 / sin(beta - theta)

    @staticmethod
    def calc_mach_normal_behind_shock_from_mach_behind_shock(
        mach2: float, beta: float, theta: float
    ) -&gt; float:
        &#34;&#34;&#34; Calculates the normal component of the mach number behind the oblique shock 

        Args:
            mach2 (float): Mach number of flow behind the oblique shock
            beta (float): Oblique shock angle (radians)
            theta (float): Flow deflections (Wedge) angle (radians)

        Returns:
            float: Normal component of mach numnber of the flow behind the shock wave
        &#34;&#34;&#34;
        return mach2 * sin(beta - theta)

    @staticmethod
    def calc_theta_from_theta_beta_mach(beta: float, mach: float, gamma: float, offset: float = 0.0) -&gt; float:
        &#34;&#34;&#34; Impliments the Theta-Beta-Mach (TBM) equation. Solves for Theta

        Args:
            beta (float): Oblique shock angle (radians)
            mach (float): Mach number of flow ahead of the shock wave
            gamma (float): Ratio of specific heats
            offset (float, optional): [description]. Defaults to 0.0.

        Returns:
            float: Flow deflection (Wedge) angle (radians)
        &#34;&#34;&#34;
        mSqr = pow(mach, 2)
        num = mSqr * pow(sin(beta), 2) - 1
        denom = mSqr * (gamma + cos(2 * beta)) + 2
        theta = atan(2 * 1 / tan(beta) * num / denom) - offset
        return theta

    @staticmethod
    def calc_beta_from_theta_beta_mach_weak(theta: float, mach: float, gamma: float) -&gt; float:
        &#34;&#34;&#34; Impliments the Theta-Beta-Mach (TBM) equation. Solves for Beta (shock angle) assuming the shock is weak

        Args:
            theta (float): Flow deflection (Wedge) angle (radians)
            mach (float): Mach number of the flow ahead of the oblique shock
            gamma (float): ratio of specific heats

        Returns:
            float: Oblique shock angle (radians)
        &#34;&#34;&#34;
        maxShockAngle = ObliqueShockRelations.calc_max_shock_angle(mach, gamma)
        minShockAngle = ObliqueShockRelations.calc_mach_wave_angle(mach)
        return brenth(
            ObliqueShockRelations.calc_theta_from_theta_beta_mach,
            minShockAngle,
            maxShockAngle,
            args=(mach, gamma, theta),
        )

    @staticmethod
    def calc_beta_from_theta_beta_mach_strong(theta: float, mach: float, gamma: float) -&gt; float:
        &#34;&#34;&#34; Impliments the Theta-Beta-Mach (TBM) equation. Solves for Beta (shock angle) assuming a strong shock wave

        Args:
            theta (float): Flow deflection (Wedge) angle (radians)
            mach (float): Mach number of the flow ahead of the oblique shock
            gamma (float): ratio of specific heats

        Returns:
            float: Oblique shock angle (radians)
        &#34;&#34;&#34;
        maxShockAngle = ObliqueShockRelations.calc_max_shock_angle(mach, gamma)
        return brenth(
            ObliqueShockRelations.calc_theta_from_theta_beta_mach,
            maxShockAngle,
            radians(90),
            args=(mach, gamma, theta),
        )

    @staticmethod
    def calc_mach_from_theta_beta_mach(beta: float, theta: float, gamma: float) -&gt; float:
        &#34;&#34;&#34; Impliments the Theta-Beta-Mach (TBM) Equation. Solves for the mach number

        Args:
            beta (float): Oblique shock angle (radians)
            theta (float): Flow deflection (wedge) angle (radians)
            gamma (float): Ratio of specific heats

        Returns:
            float: Mach number of the flow ahead of the shock wave
        &#34;&#34;&#34;
        numerator = -2 * (1 + tan(theta) * tan(beta))
        denominator = tan(theta) * tan(beta) * (gamma + cos(2 * beta)) - 2 * (sin(beta)) ** 2
        return sqrt(numerator / denominator)

    @staticmethod
    def calc_max_flow_deflection_angle(maxShockAngle: float, mach: float, gamma: float) -&gt; float:
        &#34;&#34;&#34; Calculates the max flow deflection angle for a flow

        Args:
            maxShockAngle (float): Maximum oblique shock angle (radians)
            mach (float): Mach number of flow ahead of the oblique shock
            gamma (float): Ratio of specific heats

        Returns:
            float: Mac flow deflection angle (radians)
        &#34;&#34;&#34;
        msa = maxShockAngle
        numerator = (pow(mach, 2) * (sin(msa)) ** 2 - 1) / tan(msa)
        denominator = pow(mach, 2) * (gamma + 1) / 2 - pow(mach, 2) * (pow(sin(msa), 2)) + 1
        return atan(numerator / denominator)

    @staticmethod
    def calc_max_shock_angle(mach: float, gamma: float) -&gt; float:
        &#34;&#34;&#34; Calculates the maximum oblique shock angle 

        Args:
            mach (float): Mach number of flow ahead of the shock wave
            gamma (float): Ratio of specific heats

        Returns:
            float: Maximum value of the oblique shock angle (radians)
        &#34;&#34;&#34;
        gp1 = gamma + 1
        gm1 = gamma - 1
        # splitting up of beta_max equation
        isissq = gp1 * (1 + gm1 * pow(mach, 2) / 2 + gp1 / 16 * pow(mach, 4))
        issq = 1 / (gamma * pow(mach, 2)) * (gp1 * pow(mach, 2) / 4 + sqrt(isissq) - 1)
        return asin(sqrt(issq))

    @staticmethod
    def calc_mach_wave_angle(mach: float) -&gt; float:
        return asin(1 / mach)

    @staticmethod
    def calc_mach_from_mach_wave_angle(machAngle: float) -&gt; float:
        &#34;&#34;&#34; Calculates the Mach number fromt he mach wave angle

        Args:
            machAngle (float): Mach wave angle (mu) (radians)

        Returns:
            float: mach number
        &#34;&#34;&#34;
        return 1 / sin(machAngle)

    def plot_theta_beta_mach_chart(self) -&gt; None:
        &#34;&#34;&#34; Plots the Theta-Beta-Mach plot from the data already in the class
        &#34;&#34;&#34;
        mach = self.mach

        machWaveAngle = degrees(ObliqueShockRelations.calc_mach_wave_angle(mach))
        maxShockAngle = degrees(ObliqueShockRelations.calc_max_shock_angle(mach, self.gamma))
        maxDeflectionAngle = degrees(
            ObliqueShockRelations.calc_max_flow_deflection_angle(radians(maxShockAngle), mach, self.gamma)
        )

        weakFlowDeflectionAngles = np.linspace(0, maxDeflectionAngle - 0.1, 100)
        weakShockAngles = np.zeros(weakFlowDeflectionAngles.shape)
        strongShockAngles = np.zeros(weakFlowDeflectionAngles.shape)

        for ii in range(weakFlowDeflectionAngles.shape[0]):
            if weakFlowDeflectionAngles[ii] == 0:
                weakShockAngles[ii] = machWaveAngle
                strongShockAngles[ii] = 90
                continue

            weakShockAngles[ii] = degrees(
                ObliqueShockRelations.calc_beta_from_theta_beta_mach_weak(
                    radians(weakFlowDeflectionAngles[ii]), mach, self.gamma
                )
            )
            strongShockAngles[ii] = degrees(
                ObliqueShockRelations.calc_beta_from_theta_beta_mach_strong(
                    radians(weakFlowDeflectionAngles[ii]), mach, self.gamma
                )
            )

        weakFlowDeflectionAngles = np.append(weakFlowDeflectionAngles, [maxDeflectionAngle])
        strongShockAngles = np.append(strongShockAngles, [maxShockAngle])
        weakShockAngles = np.append(weakShockAngles, [maxShockAngle])

        vertPointLine = np.linspace(0, self.shockAngle, 20)
        horzPointLine = np.linspace(0, self.wedgeAngle, 20)

        _, ax = plt.subplots(1, 1)

        ax.plot(weakFlowDeflectionAngles, weakShockAngles, label=&#34; Oblique Weak Shock&#34;)
        ax.plot(weakFlowDeflectionAngles, strongShockAngles, label=&#34;Oblique Strong Shock&#34;)

        shockangle = degrees(self.shockAngle)
        wedgeAngle = degrees(self.wedgeAngle)
        ax.scatter(wedgeAngle, shockangle, label=&#34;This Flow&#34;, color=&#34;r&#34;)
        # ax.plot(np.ones(vertPointLine.shape) * self.wedgeAngle, vertPointLine, &#39;g&#39;)
        # ax.plot(horzPointLine, np.ones(horzPointLine.shape) * self.shockAngle, &#39;g&#39;)
        ax.annotate(
            &#34;Shock {}\nWedge {}&#34;.format(round(maxShockAngle, 2), round(maxDeflectionAngle, 2)),
            xy=(maxDeflectionAngle, maxShockAngle),
            xytext=(maxDeflectionAngle + 0.02 * maxDeflectionAngle, maxShockAngle + 0.1 * maxShockAngle),
            arrowprops=dict(facecolor=&#34;black&#34;, shrink=0.05),
        )
        ax.annotate(
            &#34;Shock {}\nWedge {}&#34;.format(round(shockangle, 2), round(wedgeAngle, 2)),
            xy=(wedgeAngle, shockangle),
            xytext=(wedgeAngle - 0.2 * wedgeAngle, shockangle - 0.4 * shockangle),
            arrowprops=dict(facecolor=&#34;black&#34;, shrink=0.05),
        )
        # ax.set_xlim(0, maxDeflectionAngle + 5)
        # ax.set_ylim(0, 90)
        ax.set_xticks([num for num in range(0, int(maxDeflectionAngle) + 5, 2)])
        ax.set_yticks([num for num in range(0, 92, 2)])
        ax.set_xlabel(&#34;Flow Deflection Angle, \u03B8 (\u00b0)&#34;)
        ax.set_ylabel(&#34;Shock Anlge, \u03B2 (\u00b0)&#34;)
        ax.set_title(&#34;Mach {} Flow&#34;.format(round(self.mach, self.precision)))
        ax.legend()
        ax.grid()
        plt.show()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="CompAero.ObliqueShockRelations.ObliqueShockRelations"><code class="flex name class">
<span>class <span class="ident">ObliqueShockRelations</span></span>
<span>(</span><span>gamma: float, useDegrees: bool = True, shockAngle: float = nan, wedgeAngle: float = nan, mn1: float = nan, mn2: float = nan, mach: float = nan, p2_p1: float = nan, rho2_rho1: float = nan, t2_t1: float = nan, po2_po1: float = nan, po2_p1: float = nan, m2: float = nan, shockType: <a title="CompAero.internal.ShockType" href="internal.html#CompAero.internal.ShockType">ShockType</a> = ShockType.WEAK)</span>
</code></dt>
<dd>
<div class="desc"><p>This class is a collective name space for basic calculations regarding Oblique Shock Properties.
The constructor of this class can also determine the entire state of the flow given a partial state of the flow </p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>gamma</code></strong> :&ensp;<code>float</code></dt>
<dd>Ratio of specific heats</dd>
<dt><strong><code>useDegrees</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Angles provided to class are in degrees. Output will still be in radians. Defaults to True.</dd>
<dt><strong><code>shockAngle</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Angle of the oblique shock wave. Defaults to nan.</dd>
<dt><strong><code>wedgeAngle</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Angle of the wedge that is deflecting the flow. Defaults to nan.</dd>
<dt><strong><code>mn1</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Normal component of mach number ahead of the shock. Defaults to nan.</dd>
<dt><strong><code>mn2</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Normal component of mach number behind the shock. Defaults to nan.</dd>
<dt><strong><code>mach</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Mach number ahead of the shock. Defaults to nan.</dd>
<dt><strong><code>p2_p1</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Ratio of pressure behind shock wave to ahead of shock wave. Defaults to nan.</dd>
<dt><strong><code>rho2_rho1</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Ratio of density behind shock wave to ahead of shock wave. Defaults to nan.</dd>
<dt><strong><code>t2_t1</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Ratio of temperature behind shock wave to ahead of shock wave. Defaults to nan.</dd>
<dt><strong><code>po2_po1</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Ratio of total pressure to behind shock wave to ahead of shock wave. Defaults to nan.</dd>
<dt><strong><code>po2_p1</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Ratio Total pressure behind shock wave to static pressure ahead of shock wave. Defaults to nan.</dd>
<dt><strong><code>m2</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>mach number behind shock wave. Defaults to nan.</dd>
<dt><strong><code>shockType</code></strong> :&ensp;<code>ShockType</code>, optional</dt>
<dd>Describes whether the oblique shock is a Week or Strong shock. Defaults to ShockType.WEAK.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>RuntimeError</code></dt>
<dd>If shock wave angle is found to be less than the mach wave angle at</dd>
<dt><code>RuntimeError</code></dt>
<dd>If the deflection angle is found to be greater than the max deflection angle for the flow</dd>
<dt><code>GammaNotDefinedError</code></dt>
<dd>Raised if Gamma is undefined</dd>
<dt><code>InvalidOptionCombinationError</code></dt>
<dd>Raised if an invalid combination of parameters is given and flow state cannot be determined</dd>
</dl>
<h2 id="valid_combinations_of_parameters">Valid_Combinations_Of_Parameters</h2>
<p>1: gamma, mach, shock angle</p>
<ol>
<li>gamma, mach, wedge angle</li>
</ol>
<p>2: gamma, mach normal 1, shock angle </p>
<p>3: gamma, mach behind shock, wedge angle, shock angle</p>
<p>4: gamma, shock angle, wedge angle</p>
<p>5: gamma, P2/P1, shock angle</p>
<p>6: gamma, Rho2/Rho1, shock angle</p>
<p>7: gamma, T2/T1, shock angle</p>
<p>8: gamma, P02/P01, shock angle</p>
<p>9: gamma, P02/P1, shock angle</p>
<p>10: gamma, dwnStrm_mach, shock angle</p>
<p>This class is a collective name space for basic calculations regarding Normal Shock Properties.
The constructor of this class can also determine the entire state of the flow given a partial state of the flow </p>
<h2 id="args_1">Args</h2>
<dl>
<dt><strong><code>gamma</code></strong> :&ensp;<code>float</code></dt>
<dd>Ratio of specific heats</dd>
<dt><strong><code>mach</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>mach number of the flow. Defaults to nan.</dd>
<dt><strong><code>p2_p1</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Ratio of pressure behind shock wave to ahead of shock wave. Defaults to nan.</dd>
<dt><strong><code>rho2_rho1</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Ratio of density behind shock wave to ahead of shock wave. Defaults to nan.</dd>
<dt><strong><code>t2_t1</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Ratio of temperature behind shock wave to ahead of shock wave. Defaults to nan.</dd>
<dt><strong><code>po2_po1</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Ratio of total pressure to behind shock wave to ahead of shock wave. Defaults to nan.</dd>
<dt><strong><code>po2_p1</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Ratio Total pressure behind shock wave to static pressure ahead of shock wave. Defaults to nan.</dd>
<dt><strong><code>m2</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>mach number behind shock wave. Defaults to nan.</dd>
</dl>
<p>Raises:
GammaNotDefinedError: Raised if Gamma is undefined
InvalidOptionCombinationError: Raised if an invalid combination of parameters is given and flow state cannot be determined</p>
<p>Useage:
To use this class pass gamma and one of the known parameters of the flow and the rest are calculated. </p>
<h2 id="valid_combinations_of_parameters_1">Valid_Combinations_Of_Parameters</h2>
<p>1: gamma, mach</p>
<p>2: gamma, P2/P1</p>
<p>3: gamma, Rho2/Rho1</p>
<p>4: gamma, T2/T1</p>
<p>5: gamma, P02/P01</p>
<p>6: gamma, P02/P1</p>
<p>7: gamma, dwnStrm_mach</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ObliqueShockRelations(NormalShockRelations):
    &#34;&#34;&#34; This class is a collective name space for basic calculations regarding Oblique Shock Properties. 
    The constructor of this class can also determine the entire state of the flow given a partial state of the flow 

    Args:
        gamma (float): Ratio of specific heats
        useDegrees (bool, optional): Angles provided to class are in degrees. Output will still be in radians. Defaults to True.
        shockAngle (float, optional): Angle of the oblique shock wave. Defaults to nan.
        wedgeAngle (float, optional): Angle of the wedge that is deflecting the flow. Defaults to nan.
        mn1 (float, optional): Normal component of mach number ahead of the shock. Defaults to nan.
        mn2 (float, optional): Normal component of mach number behind the shock. Defaults to nan.
        mach (float, optional): Mach number ahead of the shock. Defaults to nan.
        p2_p1 (float, optional): Ratio of pressure behind shock wave to ahead of shock wave. Defaults to nan.
        rho2_rho1 (float, optional): Ratio of density behind shock wave to ahead of shock wave. Defaults to nan.
        t2_t1 (float, optional): Ratio of temperature behind shock wave to ahead of shock wave. Defaults to nan.
        po2_po1 (float, optional): Ratio of total pressure to behind shock wave to ahead of shock wave. Defaults to nan.
        po2_p1 (float, optional): Ratio Total pressure behind shock wave to static pressure ahead of shock wave. Defaults to nan.
        m2 (float, optional): mach number behind shock wave. Defaults to nan.
        shockType (ShockType, optional): Describes whether the oblique shock is a Week or Strong shock. Defaults to ShockType.WEAK.

    Raises:
        RuntimeError: If shock wave angle is found to be less than the mach wave angle at
        RuntimeError: If the deflection angle is found to be greater than the max deflection angle for the flow
        GammaNotDefinedError: Raised if Gamma is undefined
        InvalidOptionCombinationError: Raised if an invalid combination of parameters is given and flow state cannot be determined
        
    Valid_Combinations_of_Parameters:
        1: gamma, mach, shock angle\n
        2. gamma, mach, wedge angle\n
        2: gamma, mach normal 1, shock angle \n
        3: gamma, mach behind shock, wedge angle, shock angle\n
        4: gamma, shock angle, wedge angle\n
        5: gamma, P2/P1, shock angle\n
        6: gamma, Rho2/Rho1, shock angle\n
        7: gamma, T2/T1, shock angle\n
        8: gamma, P02/P01, shock angle\n
        9: gamma, P02/P1, shock angle\n
        10: gamma, dwnStrm_mach, shock angle\n
    &#34;&#34;&#34;

    def __init__(
        self,
        gamma: float,
        useDegrees: bool = True,
        shockAngle: float = nan,
        wedgeAngle: float = nan,
        mn1: float = nan,
        mn2: float = nan,
        mach: float = nan,
        p2_p1: float = nan,
        rho2_rho1: float = nan,
        t2_t1: float = nan,
        po2_po1: float = nan,
        po2_p1: float = nan,
        m2: float = nan,
        shockType: ShockType = ShockType.WEAK,
    ) -&gt; None:
        self.useDegrees = useDegrees
        &#34;&#34;&#34; Angles passed to the constructor are in degrees&#34;&#34;&#34;
        self.shockAngle = shockAngle
        &#34;&#34;&#34; Angle Oblique shock&#34;&#34;&#34;
        self.wedgeAngle = wedgeAngle
        &#34;&#34;&#34; Angle of the flow deflection (wedge) angle&#34;&#34;&#34;
        self.machNorm1 = mn1
        &#34;&#34;&#34; The normal component of the mach number ahead the shock wave&#34;&#34;&#34;
        self.machNorm2 = mn2
        &#34;&#34;&#34; The normal component of the mach number behind the shock wave&#34;&#34;&#34;
        self.gamma = gamma
        &#34;&#34;&#34; Ratio of specific heats &#34;&#34;&#34;
        self.mach = mach
        &#34;&#34;&#34; Mach number of the flow &#34;&#34;&#34;
        self.p2_p1 = p2_p1
        &#34;&#34;&#34; Ratio of pressure behind the shock wave to pressure before the shock wave P2/P1 &#34;&#34;&#34;
        self.rho2_rho1 = rho2_rho1
        &#34;&#34;&#34; Ratio of density behind the shock wave to density before the shock wave rho2/rho1 &#34;&#34;&#34;
        self.t2_t1 = t2_t1
        &#34;&#34;&#34; Ratio of temperature behind the shock wave to temperature before the shock wave T2/T1 &#34;&#34;&#34;
        self.po2_po1 = po2_po1
        &#34;&#34;&#34; Ratio of pressure behind the shock wave to pressure before the shock wave P2/P1 &#34;&#34;&#34;
        self.po2_p1 = po2_p1
        &#34;&#34;&#34; Ratio of total pressure behind the shock wave to pressure before the shock wave P02/P1 &#34;&#34;&#34;
        self.mach2 = m2
        &#34;&#34;&#34; Mach number behind the shock wave &#34;&#34;&#34;
        self.shockType: ShockType = shockType
        &#34;&#34;&#34; The type of shock whether it is strong or weak &#34;&#34;&#34;
        self.precision = 4
        &#34;&#34;&#34; Precision to use when printing output to the console defaults to four &#34;&#34;&#34;

        if self.useDegrees and checkValue(self.shockAngle):
            self.shockAngle = radians(self.shockAngle)
        if self.useDegrees and checkValue(self.wedgeAngle):
            self.wedgeAngle = radians(self.wedgeAngle)

        if not checkValue(self.gamma):
            raise GammaNotDefinedError()

        if checkValue([self.mach, self.shockAngle]):
            machWaveAngle = ObliqueShockRelations.calc_mach_wave_angle(self.mach)
            if self.shockAngle &lt; machWaveAngle or self.shockAngle &gt; radians(90):
                raise ValueError(&#34;Shock Angle of [{}] must be between mach wave angle of [{}] and 90 degrees for mach [{}]&#34;.format(degrees(self.shockAngle), degrees(machWaveAngle), self.mach))
        
        elif checkValue([self.mach, self.wedgeAngle]):
            maxShockAngle = ObliqueShockRelations.calc_max_shock_angle(self.mach, self.gamma)
            maxWedgeAngle = ObliqueShockRelations.calc_max_flow_deflection_angle(maxShockAngle, self.mach, self.gamma)
            if self.wedgeAngle &gt; maxWedgeAngle:
                raise ValueError(&#34;Wedge angle of [{}] is greater than a maximum wedge angle of [{}] for mach [{}]&#34;.format(degrees(self.wedgeAngle), degrees(maxWedgeAngle), self.mach))


        elif checkValue(self.machNorm1) and checkValue(self.shockAngle):
            if (self.machNorm1 &lt; 1):
                raise ValueError(&#34;Normal Component of mach ahead of shock wave must be greater than 1&#34;)
            self.mach = ObliqueShockRelations.calc_mach_ahead_shock_from_mach_normal_ahead_shock(
                self.machNorm1, self.shockAngle
            )

        elif checkValue(m2) and checkValue(self.wedgeAngle) and checkValue(self.shockAngle):
            self.machNorm2 = ObliqueShockRelations.calc_mach_normal_behind_shock_from_mach_behind_shock(
                m2, self.shockAngle, self.wedgeAngle
            )
            if self.machNorm2 &gt; 1:
                assert ValueError(&#34;Normal component of downstream mach number has to be less than 1&#34;)
            self.machNorm1 = NormalShockRelations.calc_mach_before_normal_shock_from_mach_after_shock(
                self.machNorm2, self.gamma
            )
            self.mach = ObliqueShockRelations.calc_mach_ahead_shock_from_mach_normal_ahead_shock(
                self.machNorm1, self.shockAngle
            )

        elif checkValue(self.shockAngle) and checkValue(self.wedgeAngle):
            self.mach = ObliqueShockRelations.calc_mach_from_theta_beta_mach(
                self.shockAngle, self.wedgeAngle, self.gamma
            )
            machAngle = ObliqueShockRelations.calc_mach_wave_angle(self.mach)
            maxShockAngle = ObliqueShockRelations.calc_max_shock_angle(self.mach, self.gamma)
            maxDeflectionAngle = ObliqueShockRelations.calc_max_flow_deflection_angle(
                maxShockAngle, self.mach, self.gamma
            )

            if machAngle &gt; self.shockAngle:
                raise RuntimeError(
                    &#34;Shock Angle, {}, cannot be less than that of Mach Wave, {}&#34;.format(
                        round(self.shockAngle, 4), round(machAngle, 4)
                    )
                )

            if maxDeflectionAngle &lt; self.wedgeAngle:
                raise RuntimeError(
                    &#34;SHOCK DETACHED!! Deflection Angles: Given: {}\tMax: {}&#34;.format(
                        round(self.wedgeAngle, 4), round(maxDeflectionAngle, 4)
                    )
                )

        elif checkValue([po2_p1, self.shockAngle]):
            self.machNorm1 = NormalShockRelations.calc_mach_from_po2_p1(po2_p1, self.gamma)
            self.mach = ObliqueShockRelations.calc_mach_ahead_shock_from_mach_normal_ahead_shock(
                self.machNorm1, self.shockAngle
            )

        elif checkValue([p2_p1, self.shockAngle]):
            self.machNorm1 = NormalShockRelations.calc_mach_from_p2_p1(p2_p1, self.gamma)
            self.mach = ObliqueShockRelations.calc_mach_ahead_shock_from_mach_normal_ahead_shock(
                self.machNorm1, self.shockAngle
            )

        elif checkValue([rho2_rho1, self.shockAngle]):
            self.machNorm1 = NormalShockRelations.calc_mach_from_rho2_rho1(rho2_rho1, self.gamma)
            self.mach = ObliqueShockRelations.calc_mach_ahead_shock_from_mach_normal_ahead_shock(
                self.machNorm1, self.shockAngle
            )

        elif checkValue([t2_t1, self.shockAngle]):
            self.machNorm1 = NormalShockRelations.calc_mach_from_T2_T1(t2_t1, self.gamma)
            self.mach = ObliqueShockRelations.calc_mach_ahead_shock_from_mach_normal_ahead_shock(
                self.machNorm1, self.shockAngle
            )

        elif checkValue([po2_po1, self.shockAngle]):
            self.machNorm1 = NormalShockRelations.calc_mach_from_po2_po1(po2_po1, self.gamma)
            self.mach = ObliqueShockRelations.calc_mach_ahead_shock_from_mach_normal_ahead_shock(
                self.machNorm1, self.shockAngle
            )

        elif checkValue(self.machNorm2) and checkValue(self.shockAngle):
            self.machNorm1 = NormalShockRelations.calc_mach_before_normal_shock_from_mach_after_shock(
                self.machNorm2, self.gamma
            )
            self.mach = ObliqueShockRelations.calc_mach_ahead_shock_from_mach_normal_ahead_shock(
                self.machNorm1, self.shockAngle
            )

        else:
            raise InvalidOptionCombinationError()

        if checkValue(self.mach) and ((checkValue(self.shockAngle) or checkValue(self.wedgeAngle))):
            self.__calculateState()

        super().__init__(self.gamma, mach=self.machNorm1)
        self.mach = ObliqueShockRelations.calc_mach_ahead_shock_from_mach_normal_ahead_shock(
            self.machNorm1, self.shockAngle
        )
        self.machNorm2 = self.mach2
        self.mach2 = ObliqueShockRelations.calc_mach_behind_shock(
            self.machNorm2, self.wedgeAngle, self.shockAngle
        )
        
        if self.useDegrees:
            self.wedgeAngle = degrees(self.wedgeAngle)
            self.shockAngle = degrees(self.shockAngle)

    def __calculateState(self) -&gt; None:
        if checkValue(self.wedgeAngle):
            if self.shockType == ShockType.WEAK:
                self.shockAngle = ObliqueShockRelations.calc_beta_from_theta_beta_mach_weak(
                    self.wedgeAngle, self.mach, self.gamma
                )

            elif self.shockType == ShockType.STRONG:
                self.shockAngle = ObliqueShockRelations.calc_beta_from_theta_beta_mach_strong(
                    self.wedgeAngle, self.mach, self.gamma
                )

            else:
                raise ValueError(
                    &#34;Incorrect shock type specified -&gt; [{}]. Choices: Strong, Weak&#34;.format(
                        self.shockType.name
                    )
                )

        elif checkValue(self.shockAngle):
            self.wedgeAngle = ObliqueShockRelations.calc_theta_from_theta_beta_mach(
                self.shockAngle, self.mach, self.gamma
            )

        self.machNorm1 = ObliqueShockRelations.calc_mach_normal_ahead_shock(self.mach, self.shockAngle)

    def __str__(self) -&gt; str:
        return &#34;&#34;.join(
            [
                named_header(&#34;Oblique Shock Relations at Mach&#34;, self.mach, self.precision),
                seperator(),
                named_subheader(&#34;Upstream Conditions&#34;),
                to_string(lcg.gamma, self.gamma, self.precision),
                to_string(&#34;Mach&#34;, self.mach, self.precision, dot_line=True),
                to_string(&#34;Mach Normal Component&#34;, self.machNorm1, self.precision),
                to_string(
                    &#34;Flow Deflection Angle {}&#34;.format(lcg.theta),
                    self.wedgeAngle,
                    self.precision,
                    dot_line=True,
                ),
                to_string(&#34;Shock Angle {}&#34;.format(lcg.beta), self.shockAngle, self.precision),
                to_string(&#34;Flow Turn Type&#34;, self.shockType.name, self.precision),
                seperator(),
                named_subheader(&#34;Shock Jump Conditions&#34;),
                to_string(&#34;P2/P1&#34;, self.p2_p1, self.precision),
                to_string(&#34;{}2/{}1&#34;.format(*[lcg.rho] * 2), self.rho2_rho1, self.precision, dot_line=True),
                to_string(&#34;T2/T1&#34;, self.t2_t1, self.precision),
                to_string(&#34;P02/P01&#34;, self.po2_po1, self.precision, dot_line=True),
                to_string(&#34;P02/P1&#34;, self.po2_p1, self.precision),
                seperator(),
                named_subheader(&#34;Downstream Conditions&#34;),
                to_string(&#34;Mach&#34;, self.mach2, self.precision, dot_line=True),
                to_string(&#34;Mach Normal Component&#34;, self.machNorm2, self.precision),
                footer(),
            ]
        )

    @staticmethod
    def calc_mach_normal_ahead_shock(mach: float, beta: float) -&gt; float:
        &#34;&#34;&#34; Calculates the normal component of the mach number ahead of the shock wave

        Args:
            mach (float): Mach number of flow ahead of shock wave
            beta (float): Angle of oblique shock in radians

        Raises:
            ValueError: Raised if mach number is less than 1.0

        Returns:
            float: Normal component of upstream mach number
        &#34;&#34;&#34;
        if mach &lt; 1.0:
            raise ValueError(&#34;Normal Shocks Require a mach greater than 1&#34;)

        machWave = ObliqueShockRelations.calc_mach_wave_angle(mach)

        if abs(beta - machWave) &lt; 1e-5:
            return 1.0

        if beta &lt; machWave:
            return nan

        return mach * sin(beta)

    @staticmethod
    def calc_mach_ahead_shock_from_mach_normal_ahead_shock(machNormal1: float, beta: float) -&gt; float:
        &#34;&#34;&#34; Calculates the upstream mach number from the normal component of the upstream mach number

        Args:
            machNormal1 (float): Normal Component of mach number ahead of the shock wave
            beta (float): Angle of oblique shock in radians

        Returns:
            float: Returns value of mach number of the flow ahead of the shock wave
        &#34;&#34;&#34;
        return machNormal1 / sin(beta)

    @staticmethod
    def calc_beta_from_mach_mach_normal_ahead_shock(mach: float, machNormal1: float) -&gt; float:
        &#34;&#34;&#34; Calculates the Oblique shock angle from the normal component of the mach number that is ahead of the shock wave

        Args:
            mach (float): Mach number of the flow ahead of the shock wave
            machNormal1 (float): Normal Component of mach number of the flow that is ahead of the oblique shock wave

        Returns:
            float: Oblique Shock Angle
        &#34;&#34;&#34;
        return asin(machNormal1 / mach)

    @staticmethod
    def calc_mach_behind_shock(machNormal2: float, theta: float, beta: float) -&gt; float:
        &#34;&#34;&#34; Calculates the Mach number behind the oblique shock wave

        Args:
            machNormal2 (float): Normal Component of the mach number behind the shock wave
            theta (float): Flow Deflection Angle (radians) (Wedge angle)
            beta (float): Oblique shock angle (radians)

        Returns:
            float: Mach number of flow behind the oblique shock
        &#34;&#34;&#34;
        return machNormal2 / sin(beta - theta)

    @staticmethod
    def calc_mach_normal_behind_shock_from_mach_behind_shock(
        mach2: float, beta: float, theta: float
    ) -&gt; float:
        &#34;&#34;&#34; Calculates the normal component of the mach number behind the oblique shock 

        Args:
            mach2 (float): Mach number of flow behind the oblique shock
            beta (float): Oblique shock angle (radians)
            theta (float): Flow deflections (Wedge) angle (radians)

        Returns:
            float: Normal component of mach numnber of the flow behind the shock wave
        &#34;&#34;&#34;
        return mach2 * sin(beta - theta)

    @staticmethod
    def calc_theta_from_theta_beta_mach(beta: float, mach: float, gamma: float, offset: float = 0.0) -&gt; float:
        &#34;&#34;&#34; Impliments the Theta-Beta-Mach (TBM) equation. Solves for Theta

        Args:
            beta (float): Oblique shock angle (radians)
            mach (float): Mach number of flow ahead of the shock wave
            gamma (float): Ratio of specific heats
            offset (float, optional): [description]. Defaults to 0.0.

        Returns:
            float: Flow deflection (Wedge) angle (radians)
        &#34;&#34;&#34;
        mSqr = pow(mach, 2)
        num = mSqr * pow(sin(beta), 2) - 1
        denom = mSqr * (gamma + cos(2 * beta)) + 2
        theta = atan(2 * 1 / tan(beta) * num / denom) - offset
        return theta

    @staticmethod
    def calc_beta_from_theta_beta_mach_weak(theta: float, mach: float, gamma: float) -&gt; float:
        &#34;&#34;&#34; Impliments the Theta-Beta-Mach (TBM) equation. Solves for Beta (shock angle) assuming the shock is weak

        Args:
            theta (float): Flow deflection (Wedge) angle (radians)
            mach (float): Mach number of the flow ahead of the oblique shock
            gamma (float): ratio of specific heats

        Returns:
            float: Oblique shock angle (radians)
        &#34;&#34;&#34;
        maxShockAngle = ObliqueShockRelations.calc_max_shock_angle(mach, gamma)
        minShockAngle = ObliqueShockRelations.calc_mach_wave_angle(mach)
        return brenth(
            ObliqueShockRelations.calc_theta_from_theta_beta_mach,
            minShockAngle,
            maxShockAngle,
            args=(mach, gamma, theta),
        )

    @staticmethod
    def calc_beta_from_theta_beta_mach_strong(theta: float, mach: float, gamma: float) -&gt; float:
        &#34;&#34;&#34; Impliments the Theta-Beta-Mach (TBM) equation. Solves for Beta (shock angle) assuming a strong shock wave

        Args:
            theta (float): Flow deflection (Wedge) angle (radians)
            mach (float): Mach number of the flow ahead of the oblique shock
            gamma (float): ratio of specific heats

        Returns:
            float: Oblique shock angle (radians)
        &#34;&#34;&#34;
        maxShockAngle = ObliqueShockRelations.calc_max_shock_angle(mach, gamma)
        return brenth(
            ObliqueShockRelations.calc_theta_from_theta_beta_mach,
            maxShockAngle,
            radians(90),
            args=(mach, gamma, theta),
        )

    @staticmethod
    def calc_mach_from_theta_beta_mach(beta: float, theta: float, gamma: float) -&gt; float:
        &#34;&#34;&#34; Impliments the Theta-Beta-Mach (TBM) Equation. Solves for the mach number

        Args:
            beta (float): Oblique shock angle (radians)
            theta (float): Flow deflection (wedge) angle (radians)
            gamma (float): Ratio of specific heats

        Returns:
            float: Mach number of the flow ahead of the shock wave
        &#34;&#34;&#34;
        numerator = -2 * (1 + tan(theta) * tan(beta))
        denominator = tan(theta) * tan(beta) * (gamma + cos(2 * beta)) - 2 * (sin(beta)) ** 2
        return sqrt(numerator / denominator)

    @staticmethod
    def calc_max_flow_deflection_angle(maxShockAngle: float, mach: float, gamma: float) -&gt; float:
        &#34;&#34;&#34; Calculates the max flow deflection angle for a flow

        Args:
            maxShockAngle (float): Maximum oblique shock angle (radians)
            mach (float): Mach number of flow ahead of the oblique shock
            gamma (float): Ratio of specific heats

        Returns:
            float: Mac flow deflection angle (radians)
        &#34;&#34;&#34;
        msa = maxShockAngle
        numerator = (pow(mach, 2) * (sin(msa)) ** 2 - 1) / tan(msa)
        denominator = pow(mach, 2) * (gamma + 1) / 2 - pow(mach, 2) * (pow(sin(msa), 2)) + 1
        return atan(numerator / denominator)

    @staticmethod
    def calc_max_shock_angle(mach: float, gamma: float) -&gt; float:
        &#34;&#34;&#34; Calculates the maximum oblique shock angle 

        Args:
            mach (float): Mach number of flow ahead of the shock wave
            gamma (float): Ratio of specific heats

        Returns:
            float: Maximum value of the oblique shock angle (radians)
        &#34;&#34;&#34;
        gp1 = gamma + 1
        gm1 = gamma - 1
        # splitting up of beta_max equation
        isissq = gp1 * (1 + gm1 * pow(mach, 2) / 2 + gp1 / 16 * pow(mach, 4))
        issq = 1 / (gamma * pow(mach, 2)) * (gp1 * pow(mach, 2) / 4 + sqrt(isissq) - 1)
        return asin(sqrt(issq))

    @staticmethod
    def calc_mach_wave_angle(mach: float) -&gt; float:
        return asin(1 / mach)

    @staticmethod
    def calc_mach_from_mach_wave_angle(machAngle: float) -&gt; float:
        &#34;&#34;&#34; Calculates the Mach number fromt he mach wave angle

        Args:
            machAngle (float): Mach wave angle (mu) (radians)

        Returns:
            float: mach number
        &#34;&#34;&#34;
        return 1 / sin(machAngle)

    def plot_theta_beta_mach_chart(self) -&gt; None:
        &#34;&#34;&#34; Plots the Theta-Beta-Mach plot from the data already in the class
        &#34;&#34;&#34;
        mach = self.mach

        machWaveAngle = degrees(ObliqueShockRelations.calc_mach_wave_angle(mach))
        maxShockAngle = degrees(ObliqueShockRelations.calc_max_shock_angle(mach, self.gamma))
        maxDeflectionAngle = degrees(
            ObliqueShockRelations.calc_max_flow_deflection_angle(radians(maxShockAngle), mach, self.gamma)
        )

        weakFlowDeflectionAngles = np.linspace(0, maxDeflectionAngle - 0.1, 100)
        weakShockAngles = np.zeros(weakFlowDeflectionAngles.shape)
        strongShockAngles = np.zeros(weakFlowDeflectionAngles.shape)

        for ii in range(weakFlowDeflectionAngles.shape[0]):
            if weakFlowDeflectionAngles[ii] == 0:
                weakShockAngles[ii] = machWaveAngle
                strongShockAngles[ii] = 90
                continue

            weakShockAngles[ii] = degrees(
                ObliqueShockRelations.calc_beta_from_theta_beta_mach_weak(
                    radians(weakFlowDeflectionAngles[ii]), mach, self.gamma
                )
            )
            strongShockAngles[ii] = degrees(
                ObliqueShockRelations.calc_beta_from_theta_beta_mach_strong(
                    radians(weakFlowDeflectionAngles[ii]), mach, self.gamma
                )
            )

        weakFlowDeflectionAngles = np.append(weakFlowDeflectionAngles, [maxDeflectionAngle])
        strongShockAngles = np.append(strongShockAngles, [maxShockAngle])
        weakShockAngles = np.append(weakShockAngles, [maxShockAngle])

        vertPointLine = np.linspace(0, self.shockAngle, 20)
        horzPointLine = np.linspace(0, self.wedgeAngle, 20)

        _, ax = plt.subplots(1, 1)

        ax.plot(weakFlowDeflectionAngles, weakShockAngles, label=&#34; Oblique Weak Shock&#34;)
        ax.plot(weakFlowDeflectionAngles, strongShockAngles, label=&#34;Oblique Strong Shock&#34;)

        shockangle = degrees(self.shockAngle)
        wedgeAngle = degrees(self.wedgeAngle)
        ax.scatter(wedgeAngle, shockangle, label=&#34;This Flow&#34;, color=&#34;r&#34;)
        # ax.plot(np.ones(vertPointLine.shape) * self.wedgeAngle, vertPointLine, &#39;g&#39;)
        # ax.plot(horzPointLine, np.ones(horzPointLine.shape) * self.shockAngle, &#39;g&#39;)
        ax.annotate(
            &#34;Shock {}\nWedge {}&#34;.format(round(maxShockAngle, 2), round(maxDeflectionAngle, 2)),
            xy=(maxDeflectionAngle, maxShockAngle),
            xytext=(maxDeflectionAngle + 0.02 * maxDeflectionAngle, maxShockAngle + 0.1 * maxShockAngle),
            arrowprops=dict(facecolor=&#34;black&#34;, shrink=0.05),
        )
        ax.annotate(
            &#34;Shock {}\nWedge {}&#34;.format(round(shockangle, 2), round(wedgeAngle, 2)),
            xy=(wedgeAngle, shockangle),
            xytext=(wedgeAngle - 0.2 * wedgeAngle, shockangle - 0.4 * shockangle),
            arrowprops=dict(facecolor=&#34;black&#34;, shrink=0.05),
        )
        # ax.set_xlim(0, maxDeflectionAngle + 5)
        # ax.set_ylim(0, 90)
        ax.set_xticks([num for num in range(0, int(maxDeflectionAngle) + 5, 2)])
        ax.set_yticks([num for num in range(0, 92, 2)])
        ax.set_xlabel(&#34;Flow Deflection Angle, \u03B8 (\u00b0)&#34;)
        ax.set_ylabel(&#34;Shock Anlge, \u03B2 (\u00b0)&#34;)
        ax.set_title(&#34;Mach {} Flow&#34;.format(round(self.mach, self.precision)))
        ax.legend()
        ax.grid()
        plt.show()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="CompAero.NormalShockRelations.NormalShockRelations" href="NormalShockRelations.html#CompAero.NormalShockRelations.NormalShockRelations">NormalShockRelations</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="CompAero.ObliqueShockRelations.ObliqueShockRelations.calc_beta_from_mach_mach_normal_ahead_shock"><code class="name flex">
<span>def <span class="ident">calc_beta_from_mach_mach_normal_ahead_shock</span></span>(<span>mach: float, machNormal1: float) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the Oblique shock angle from the normal component of the mach number that is ahead of the shock wave</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>mach</code></strong> :&ensp;<code>float</code></dt>
<dd>Mach number of the flow ahead of the shock wave</dd>
<dt><strong><code>machNormal1</code></strong> :&ensp;<code>float</code></dt>
<dd>Normal Component of mach number of the flow that is ahead of the oblique shock wave</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Oblique Shock Angle</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def calc_beta_from_mach_mach_normal_ahead_shock(mach: float, machNormal1: float) -&gt; float:
    &#34;&#34;&#34; Calculates the Oblique shock angle from the normal component of the mach number that is ahead of the shock wave

    Args:
        mach (float): Mach number of the flow ahead of the shock wave
        machNormal1 (float): Normal Component of mach number of the flow that is ahead of the oblique shock wave

    Returns:
        float: Oblique Shock Angle
    &#34;&#34;&#34;
    return asin(machNormal1 / mach)</code></pre>
</details>
</dd>
<dt id="CompAero.ObliqueShockRelations.ObliqueShockRelations.calc_beta_from_theta_beta_mach_strong"><code class="name flex">
<span>def <span class="ident">calc_beta_from_theta_beta_mach_strong</span></span>(<span>theta: float, mach: float, gamma: float) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Impliments the Theta-Beta-Mach (TBM) equation. Solves for Beta (shock angle) assuming a strong shock wave</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>theta</code></strong> :&ensp;<code>float</code></dt>
<dd>Flow deflection (Wedge) angle (radians)</dd>
<dt><strong><code>mach</code></strong> :&ensp;<code>float</code></dt>
<dd>Mach number of the flow ahead of the oblique shock</dd>
<dt><strong><code>gamma</code></strong> :&ensp;<code>float</code></dt>
<dd>ratio of specific heats</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Oblique shock angle (radians)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def calc_beta_from_theta_beta_mach_strong(theta: float, mach: float, gamma: float) -&gt; float:
    &#34;&#34;&#34; Impliments the Theta-Beta-Mach (TBM) equation. Solves for Beta (shock angle) assuming a strong shock wave

    Args:
        theta (float): Flow deflection (Wedge) angle (radians)
        mach (float): Mach number of the flow ahead of the oblique shock
        gamma (float): ratio of specific heats

    Returns:
        float: Oblique shock angle (radians)
    &#34;&#34;&#34;
    maxShockAngle = ObliqueShockRelations.calc_max_shock_angle(mach, gamma)
    return brenth(
        ObliqueShockRelations.calc_theta_from_theta_beta_mach,
        maxShockAngle,
        radians(90),
        args=(mach, gamma, theta),
    )</code></pre>
</details>
</dd>
<dt id="CompAero.ObliqueShockRelations.ObliqueShockRelations.calc_beta_from_theta_beta_mach_weak"><code class="name flex">
<span>def <span class="ident">calc_beta_from_theta_beta_mach_weak</span></span>(<span>theta: float, mach: float, gamma: float) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Impliments the Theta-Beta-Mach (TBM) equation. Solves for Beta (shock angle) assuming the shock is weak</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>theta</code></strong> :&ensp;<code>float</code></dt>
<dd>Flow deflection (Wedge) angle (radians)</dd>
<dt><strong><code>mach</code></strong> :&ensp;<code>float</code></dt>
<dd>Mach number of the flow ahead of the oblique shock</dd>
<dt><strong><code>gamma</code></strong> :&ensp;<code>float</code></dt>
<dd>ratio of specific heats</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Oblique shock angle (radians)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def calc_beta_from_theta_beta_mach_weak(theta: float, mach: float, gamma: float) -&gt; float:
    &#34;&#34;&#34; Impliments the Theta-Beta-Mach (TBM) equation. Solves for Beta (shock angle) assuming the shock is weak

    Args:
        theta (float): Flow deflection (Wedge) angle (radians)
        mach (float): Mach number of the flow ahead of the oblique shock
        gamma (float): ratio of specific heats

    Returns:
        float: Oblique shock angle (radians)
    &#34;&#34;&#34;
    maxShockAngle = ObliqueShockRelations.calc_max_shock_angle(mach, gamma)
    minShockAngle = ObliqueShockRelations.calc_mach_wave_angle(mach)
    return brenth(
        ObliqueShockRelations.calc_theta_from_theta_beta_mach,
        minShockAngle,
        maxShockAngle,
        args=(mach, gamma, theta),
    )</code></pre>
</details>
</dd>
<dt id="CompAero.ObliqueShockRelations.ObliqueShockRelations.calc_mach_ahead_shock_from_mach_normal_ahead_shock"><code class="name flex">
<span>def <span class="ident">calc_mach_ahead_shock_from_mach_normal_ahead_shock</span></span>(<span>machNormal1: float, beta: float) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the upstream mach number from the normal component of the upstream mach number</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>machNormal1</code></strong> :&ensp;<code>float</code></dt>
<dd>Normal Component of mach number ahead of the shock wave</dd>
<dt><strong><code>beta</code></strong> :&ensp;<code>float</code></dt>
<dd>Angle of oblique shock in radians</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Returns value of mach number of the flow ahead of the shock wave</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def calc_mach_ahead_shock_from_mach_normal_ahead_shock(machNormal1: float, beta: float) -&gt; float:
    &#34;&#34;&#34; Calculates the upstream mach number from the normal component of the upstream mach number

    Args:
        machNormal1 (float): Normal Component of mach number ahead of the shock wave
        beta (float): Angle of oblique shock in radians

    Returns:
        float: Returns value of mach number of the flow ahead of the shock wave
    &#34;&#34;&#34;
    return machNormal1 / sin(beta)</code></pre>
</details>
</dd>
<dt id="CompAero.ObliqueShockRelations.ObliqueShockRelations.calc_mach_behind_shock"><code class="name flex">
<span>def <span class="ident">calc_mach_behind_shock</span></span>(<span>machNormal2: float, theta: float, beta: float) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the Mach number behind the oblique shock wave</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>machNormal2</code></strong> :&ensp;<code>float</code></dt>
<dd>Normal Component of the mach number behind the shock wave</dd>
<dt><strong><code>theta</code></strong> :&ensp;<code>float</code></dt>
<dd>Flow Deflection Angle (radians) (Wedge angle)</dd>
<dt><strong><code>beta</code></strong> :&ensp;<code>float</code></dt>
<dd>Oblique shock angle (radians)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Mach number of flow behind the oblique shock</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def calc_mach_behind_shock(machNormal2: float, theta: float, beta: float) -&gt; float:
    &#34;&#34;&#34; Calculates the Mach number behind the oblique shock wave

    Args:
        machNormal2 (float): Normal Component of the mach number behind the shock wave
        theta (float): Flow Deflection Angle (radians) (Wedge angle)
        beta (float): Oblique shock angle (radians)

    Returns:
        float: Mach number of flow behind the oblique shock
    &#34;&#34;&#34;
    return machNormal2 / sin(beta - theta)</code></pre>
</details>
</dd>
<dt id="CompAero.ObliqueShockRelations.ObliqueShockRelations.calc_mach_from_mach_wave_angle"><code class="name flex">
<span>def <span class="ident">calc_mach_from_mach_wave_angle</span></span>(<span>machAngle: float) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the Mach number fromt he mach wave angle</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>machAngle</code></strong> :&ensp;<code>float</code></dt>
<dd>Mach wave angle (mu) (radians)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>mach number</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def calc_mach_from_mach_wave_angle(machAngle: float) -&gt; float:
    &#34;&#34;&#34; Calculates the Mach number fromt he mach wave angle

    Args:
        machAngle (float): Mach wave angle (mu) (radians)

    Returns:
        float: mach number
    &#34;&#34;&#34;
    return 1 / sin(machAngle)</code></pre>
</details>
</dd>
<dt id="CompAero.ObliqueShockRelations.ObliqueShockRelations.calc_mach_from_theta_beta_mach"><code class="name flex">
<span>def <span class="ident">calc_mach_from_theta_beta_mach</span></span>(<span>beta: float, theta: float, gamma: float) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Impliments the Theta-Beta-Mach (TBM) Equation. Solves for the mach number</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>beta</code></strong> :&ensp;<code>float</code></dt>
<dd>Oblique shock angle (radians)</dd>
<dt><strong><code>theta</code></strong> :&ensp;<code>float</code></dt>
<dd>Flow deflection (wedge) angle (radians)</dd>
<dt><strong><code>gamma</code></strong> :&ensp;<code>float</code></dt>
<dd>Ratio of specific heats</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Mach number of the flow ahead of the shock wave</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def calc_mach_from_theta_beta_mach(beta: float, theta: float, gamma: float) -&gt; float:
    &#34;&#34;&#34; Impliments the Theta-Beta-Mach (TBM) Equation. Solves for the mach number

    Args:
        beta (float): Oblique shock angle (radians)
        theta (float): Flow deflection (wedge) angle (radians)
        gamma (float): Ratio of specific heats

    Returns:
        float: Mach number of the flow ahead of the shock wave
    &#34;&#34;&#34;
    numerator = -2 * (1 + tan(theta) * tan(beta))
    denominator = tan(theta) * tan(beta) * (gamma + cos(2 * beta)) - 2 * (sin(beta)) ** 2
    return sqrt(numerator / denominator)</code></pre>
</details>
</dd>
<dt id="CompAero.ObliqueShockRelations.ObliqueShockRelations.calc_mach_normal_ahead_shock"><code class="name flex">
<span>def <span class="ident">calc_mach_normal_ahead_shock</span></span>(<span>mach: float, beta: float) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the normal component of the mach number ahead of the shock wave</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>mach</code></strong> :&ensp;<code>float</code></dt>
<dd>Mach number of flow ahead of shock wave</dd>
<dt><strong><code>beta</code></strong> :&ensp;<code>float</code></dt>
<dd>Angle of oblique shock in radians</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>Raised if mach number is less than 1.0</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Normal component of upstream mach number</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def calc_mach_normal_ahead_shock(mach: float, beta: float) -&gt; float:
    &#34;&#34;&#34; Calculates the normal component of the mach number ahead of the shock wave

    Args:
        mach (float): Mach number of flow ahead of shock wave
        beta (float): Angle of oblique shock in radians

    Raises:
        ValueError: Raised if mach number is less than 1.0

    Returns:
        float: Normal component of upstream mach number
    &#34;&#34;&#34;
    if mach &lt; 1.0:
        raise ValueError(&#34;Normal Shocks Require a mach greater than 1&#34;)

    machWave = ObliqueShockRelations.calc_mach_wave_angle(mach)

    if abs(beta - machWave) &lt; 1e-5:
        return 1.0

    if beta &lt; machWave:
        return nan

    return mach * sin(beta)</code></pre>
</details>
</dd>
<dt id="CompAero.ObliqueShockRelations.ObliqueShockRelations.calc_mach_normal_behind_shock_from_mach_behind_shock"><code class="name flex">
<span>def <span class="ident">calc_mach_normal_behind_shock_from_mach_behind_shock</span></span>(<span>mach2: float, beta: float, theta: float) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the normal component of the mach number behind the oblique shock </p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>mach2</code></strong> :&ensp;<code>float</code></dt>
<dd>Mach number of flow behind the oblique shock</dd>
<dt><strong><code>beta</code></strong> :&ensp;<code>float</code></dt>
<dd>Oblique shock angle (radians)</dd>
<dt><strong><code>theta</code></strong> :&ensp;<code>float</code></dt>
<dd>Flow deflections (Wedge) angle (radians)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Normal component of mach numnber of the flow behind the shock wave</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def calc_mach_normal_behind_shock_from_mach_behind_shock(
    mach2: float, beta: float, theta: float
) -&gt; float:
    &#34;&#34;&#34; Calculates the normal component of the mach number behind the oblique shock 

    Args:
        mach2 (float): Mach number of flow behind the oblique shock
        beta (float): Oblique shock angle (radians)
        theta (float): Flow deflections (Wedge) angle (radians)

    Returns:
        float: Normal component of mach numnber of the flow behind the shock wave
    &#34;&#34;&#34;
    return mach2 * sin(beta - theta)</code></pre>
</details>
</dd>
<dt id="CompAero.ObliqueShockRelations.ObliqueShockRelations.calc_mach_wave_angle"><code class="name flex">
<span>def <span class="ident">calc_mach_wave_angle</span></span>(<span>mach: float) ‑> float</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def calc_mach_wave_angle(mach: float) -&gt; float:
    return asin(1 / mach)</code></pre>
</details>
</dd>
<dt id="CompAero.ObliqueShockRelations.ObliqueShockRelations.calc_max_flow_deflection_angle"><code class="name flex">
<span>def <span class="ident">calc_max_flow_deflection_angle</span></span>(<span>maxShockAngle: float, mach: float, gamma: float) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the max flow deflection angle for a flow</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>maxShockAngle</code></strong> :&ensp;<code>float</code></dt>
<dd>Maximum oblique shock angle (radians)</dd>
<dt><strong><code>mach</code></strong> :&ensp;<code>float</code></dt>
<dd>Mach number of flow ahead of the oblique shock</dd>
<dt><strong><code>gamma</code></strong> :&ensp;<code>float</code></dt>
<dd>Ratio of specific heats</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Mac flow deflection angle (radians)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def calc_max_flow_deflection_angle(maxShockAngle: float, mach: float, gamma: float) -&gt; float:
    &#34;&#34;&#34; Calculates the max flow deflection angle for a flow

    Args:
        maxShockAngle (float): Maximum oblique shock angle (radians)
        mach (float): Mach number of flow ahead of the oblique shock
        gamma (float): Ratio of specific heats

    Returns:
        float: Mac flow deflection angle (radians)
    &#34;&#34;&#34;
    msa = maxShockAngle
    numerator = (pow(mach, 2) * (sin(msa)) ** 2 - 1) / tan(msa)
    denominator = pow(mach, 2) * (gamma + 1) / 2 - pow(mach, 2) * (pow(sin(msa), 2)) + 1
    return atan(numerator / denominator)</code></pre>
</details>
</dd>
<dt id="CompAero.ObliqueShockRelations.ObliqueShockRelations.calc_max_shock_angle"><code class="name flex">
<span>def <span class="ident">calc_max_shock_angle</span></span>(<span>mach: float, gamma: float) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the maximum oblique shock angle </p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>mach</code></strong> :&ensp;<code>float</code></dt>
<dd>Mach number of flow ahead of the shock wave</dd>
<dt><strong><code>gamma</code></strong> :&ensp;<code>float</code></dt>
<dd>Ratio of specific heats</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Maximum value of the oblique shock angle (radians)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def calc_max_shock_angle(mach: float, gamma: float) -&gt; float:
    &#34;&#34;&#34; Calculates the maximum oblique shock angle 

    Args:
        mach (float): Mach number of flow ahead of the shock wave
        gamma (float): Ratio of specific heats

    Returns:
        float: Maximum value of the oblique shock angle (radians)
    &#34;&#34;&#34;
    gp1 = gamma + 1
    gm1 = gamma - 1
    # splitting up of beta_max equation
    isissq = gp1 * (1 + gm1 * pow(mach, 2) / 2 + gp1 / 16 * pow(mach, 4))
    issq = 1 / (gamma * pow(mach, 2)) * (gp1 * pow(mach, 2) / 4 + sqrt(isissq) - 1)
    return asin(sqrt(issq))</code></pre>
</details>
</dd>
<dt id="CompAero.ObliqueShockRelations.ObliqueShockRelations.calc_theta_from_theta_beta_mach"><code class="name flex">
<span>def <span class="ident">calc_theta_from_theta_beta_mach</span></span>(<span>beta: float, mach: float, gamma: float, offset: float = 0.0) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Impliments the Theta-Beta-Mach (TBM) equation. Solves for Theta</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>beta</code></strong> :&ensp;<code>float</code></dt>
<dd>Oblique shock angle (radians)</dd>
<dt><strong><code>mach</code></strong> :&ensp;<code>float</code></dt>
<dd>Mach number of flow ahead of the shock wave</dd>
<dt><strong><code>gamma</code></strong> :&ensp;<code>float</code></dt>
<dd>Ratio of specific heats</dd>
<dt><strong><code>offset</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>[description]. Defaults to 0.0.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Flow deflection (Wedge) angle (radians)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def calc_theta_from_theta_beta_mach(beta: float, mach: float, gamma: float, offset: float = 0.0) -&gt; float:
    &#34;&#34;&#34; Impliments the Theta-Beta-Mach (TBM) equation. Solves for Theta

    Args:
        beta (float): Oblique shock angle (radians)
        mach (float): Mach number of flow ahead of the shock wave
        gamma (float): Ratio of specific heats
        offset (float, optional): [description]. Defaults to 0.0.

    Returns:
        float: Flow deflection (Wedge) angle (radians)
    &#34;&#34;&#34;
    mSqr = pow(mach, 2)
    num = mSqr * pow(sin(beta), 2) - 1
    denom = mSqr * (gamma + cos(2 * beta)) + 2
    theta = atan(2 * 1 / tan(beta) * num / denom) - offset
    return theta</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="CompAero.ObliqueShockRelations.ObliqueShockRelations.machNorm1"><code class="name">var <span class="ident">machNorm1</span></code></dt>
<dd>
<div class="desc"><p>The normal component of the mach number ahead the shock wave</p></div>
</dd>
<dt id="CompAero.ObliqueShockRelations.ObliqueShockRelations.machNorm2"><code class="name">var <span class="ident">machNorm2</span></code></dt>
<dd>
<div class="desc"><p>The normal component of the mach number behind the shock wave</p></div>
</dd>
<dt id="CompAero.ObliqueShockRelations.ObliqueShockRelations.shockAngle"><code class="name">var <span class="ident">shockAngle</span></code></dt>
<dd>
<div class="desc"><p>Angle Oblique shock</p></div>
</dd>
<dt id="CompAero.ObliqueShockRelations.ObliqueShockRelations.shockType"><code class="name">var <span class="ident">shockType</span></code></dt>
<dd>
<div class="desc"><p>The type of shock whether it is strong or weak</p></div>
</dd>
<dt id="CompAero.ObliqueShockRelations.ObliqueShockRelations.useDegrees"><code class="name">var <span class="ident">useDegrees</span></code></dt>
<dd>
<div class="desc"><p>Angles passed to the constructor are in degrees</p></div>
</dd>
<dt id="CompAero.ObliqueShockRelations.ObliqueShockRelations.wedgeAngle"><code class="name">var <span class="ident">wedgeAngle</span></code></dt>
<dd>
<div class="desc"><p>Angle of the flow deflection (wedge) angle</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="CompAero.ObliqueShockRelations.ObliqueShockRelations.plot_theta_beta_mach_chart"><code class="name flex">
<span>def <span class="ident">plot_theta_beta_mach_chart</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Plots the Theta-Beta-Mach plot from the data already in the class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_theta_beta_mach_chart(self) -&gt; None:
    &#34;&#34;&#34; Plots the Theta-Beta-Mach plot from the data already in the class
    &#34;&#34;&#34;
    mach = self.mach

    machWaveAngle = degrees(ObliqueShockRelations.calc_mach_wave_angle(mach))
    maxShockAngle = degrees(ObliqueShockRelations.calc_max_shock_angle(mach, self.gamma))
    maxDeflectionAngle = degrees(
        ObliqueShockRelations.calc_max_flow_deflection_angle(radians(maxShockAngle), mach, self.gamma)
    )

    weakFlowDeflectionAngles = np.linspace(0, maxDeflectionAngle - 0.1, 100)
    weakShockAngles = np.zeros(weakFlowDeflectionAngles.shape)
    strongShockAngles = np.zeros(weakFlowDeflectionAngles.shape)

    for ii in range(weakFlowDeflectionAngles.shape[0]):
        if weakFlowDeflectionAngles[ii] == 0:
            weakShockAngles[ii] = machWaveAngle
            strongShockAngles[ii] = 90
            continue

        weakShockAngles[ii] = degrees(
            ObliqueShockRelations.calc_beta_from_theta_beta_mach_weak(
                radians(weakFlowDeflectionAngles[ii]), mach, self.gamma
            )
        )
        strongShockAngles[ii] = degrees(
            ObliqueShockRelations.calc_beta_from_theta_beta_mach_strong(
                radians(weakFlowDeflectionAngles[ii]), mach, self.gamma
            )
        )

    weakFlowDeflectionAngles = np.append(weakFlowDeflectionAngles, [maxDeflectionAngle])
    strongShockAngles = np.append(strongShockAngles, [maxShockAngle])
    weakShockAngles = np.append(weakShockAngles, [maxShockAngle])

    vertPointLine = np.linspace(0, self.shockAngle, 20)
    horzPointLine = np.linspace(0, self.wedgeAngle, 20)

    _, ax = plt.subplots(1, 1)

    ax.plot(weakFlowDeflectionAngles, weakShockAngles, label=&#34; Oblique Weak Shock&#34;)
    ax.plot(weakFlowDeflectionAngles, strongShockAngles, label=&#34;Oblique Strong Shock&#34;)

    shockangle = degrees(self.shockAngle)
    wedgeAngle = degrees(self.wedgeAngle)
    ax.scatter(wedgeAngle, shockangle, label=&#34;This Flow&#34;, color=&#34;r&#34;)
    # ax.plot(np.ones(vertPointLine.shape) * self.wedgeAngle, vertPointLine, &#39;g&#39;)
    # ax.plot(horzPointLine, np.ones(horzPointLine.shape) * self.shockAngle, &#39;g&#39;)
    ax.annotate(
        &#34;Shock {}\nWedge {}&#34;.format(round(maxShockAngle, 2), round(maxDeflectionAngle, 2)),
        xy=(maxDeflectionAngle, maxShockAngle),
        xytext=(maxDeflectionAngle + 0.02 * maxDeflectionAngle, maxShockAngle + 0.1 * maxShockAngle),
        arrowprops=dict(facecolor=&#34;black&#34;, shrink=0.05),
    )
    ax.annotate(
        &#34;Shock {}\nWedge {}&#34;.format(round(shockangle, 2), round(wedgeAngle, 2)),
        xy=(wedgeAngle, shockangle),
        xytext=(wedgeAngle - 0.2 * wedgeAngle, shockangle - 0.4 * shockangle),
        arrowprops=dict(facecolor=&#34;black&#34;, shrink=0.05),
    )
    # ax.set_xlim(0, maxDeflectionAngle + 5)
    # ax.set_ylim(0, 90)
    ax.set_xticks([num for num in range(0, int(maxDeflectionAngle) + 5, 2)])
    ax.set_yticks([num for num in range(0, 92, 2)])
    ax.set_xlabel(&#34;Flow Deflection Angle, \u03B8 (\u00b0)&#34;)
    ax.set_ylabel(&#34;Shock Anlge, \u03B2 (\u00b0)&#34;)
    ax.set_title(&#34;Mach {} Flow&#34;.format(round(self.mach, self.precision)))
    ax.legend()
    ax.grid()
    plt.show()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="CompAero.NormalShockRelations.NormalShockRelations" href="NormalShockRelations.html#CompAero.NormalShockRelations.NormalShockRelations">NormalShockRelations</a></b></code>:
<ul class="hlist">
<li><code><a title="CompAero.NormalShockRelations.NormalShockRelations.calc_T2_T1" href="NormalShockRelations.html#CompAero.NormalShockRelations.NormalShockRelations.calc_T2_T1">calc_T2_T1</a></code></li>
<li><code><a title="CompAero.NormalShockRelations.NormalShockRelations.calc_mach_after_normal_shock" href="NormalShockRelations.html#CompAero.NormalShockRelations.NormalShockRelations.calc_mach_after_normal_shock">calc_mach_after_normal_shock</a></code></li>
<li><code><a title="CompAero.NormalShockRelations.NormalShockRelations.calc_mach_before_normal_shock_from_mach_after_shock" href="NormalShockRelations.html#CompAero.NormalShockRelations.NormalShockRelations.calc_mach_before_normal_shock_from_mach_after_shock">calc_mach_before_normal_shock_from_mach_after_shock</a></code></li>
<li><code><a title="CompAero.NormalShockRelations.NormalShockRelations.calc_mach_from_T2_T1" href="NormalShockRelations.html#CompAero.NormalShockRelations.NormalShockRelations.calc_mach_from_T2_T1">calc_mach_from_T2_T1</a></code></li>
<li><code><a title="CompAero.NormalShockRelations.NormalShockRelations.calc_mach_from_p2_p1" href="NormalShockRelations.html#CompAero.NormalShockRelations.NormalShockRelations.calc_mach_from_p2_p1">calc_mach_from_p2_p1</a></code></li>
<li><code><a title="CompAero.NormalShockRelations.NormalShockRelations.calc_mach_from_po2_p1" href="NormalShockRelations.html#CompAero.NormalShockRelations.NormalShockRelations.calc_mach_from_po2_p1">calc_mach_from_po2_p1</a></code></li>
<li><code><a title="CompAero.NormalShockRelations.NormalShockRelations.calc_mach_from_po2_po1" href="NormalShockRelations.html#CompAero.NormalShockRelations.NormalShockRelations.calc_mach_from_po2_po1">calc_mach_from_po2_po1</a></code></li>
<li><code><a title="CompAero.NormalShockRelations.NormalShockRelations.calc_mach_from_rho2_rho1" href="NormalShockRelations.html#CompAero.NormalShockRelations.NormalShockRelations.calc_mach_from_rho2_rho1">calc_mach_from_rho2_rho1</a></code></li>
<li><code><a title="CompAero.NormalShockRelations.NormalShockRelations.calc_p2_p1" href="NormalShockRelations.html#CompAero.NormalShockRelations.NormalShockRelations.calc_p2_p1">calc_p2_p1</a></code></li>
<li><code><a title="CompAero.NormalShockRelations.NormalShockRelations.calc_po2_p1" href="NormalShockRelations.html#CompAero.NormalShockRelations.NormalShockRelations.calc_po2_p1">calc_po2_p1</a></code></li>
<li><code><a title="CompAero.NormalShockRelations.NormalShockRelations.calc_po2_po1" href="NormalShockRelations.html#CompAero.NormalShockRelations.NormalShockRelations.calc_po2_po1">calc_po2_po1</a></code></li>
<li><code><a title="CompAero.NormalShockRelations.NormalShockRelations.calc_rho2_rho1" href="NormalShockRelations.html#CompAero.NormalShockRelations.NormalShockRelations.calc_rho2_rho1">calc_rho2_rho1</a></code></li>
<li><code><a title="CompAero.NormalShockRelations.NormalShockRelations.gamma" href="NormalShockRelations.html#CompAero.NormalShockRelations.NormalShockRelations.gamma">gamma</a></code></li>
<li><code><a title="CompAero.NormalShockRelations.NormalShockRelations.mach" href="NormalShockRelations.html#CompAero.NormalShockRelations.NormalShockRelations.mach">mach</a></code></li>
<li><code><a title="CompAero.NormalShockRelations.NormalShockRelations.mach2" href="NormalShockRelations.html#CompAero.NormalShockRelations.NormalShockRelations.mach2">mach2</a></code></li>
<li><code><a title="CompAero.NormalShockRelations.NormalShockRelations.p2_p1" href="NormalShockRelations.html#CompAero.NormalShockRelations.NormalShockRelations.p2_p1">p2_p1</a></code></li>
<li><code><a title="CompAero.NormalShockRelations.NormalShockRelations.po2_p1" href="NormalShockRelations.html#CompAero.NormalShockRelations.NormalShockRelations.po2_p1">po2_p1</a></code></li>
<li><code><a title="CompAero.NormalShockRelations.NormalShockRelations.po2_po1" href="NormalShockRelations.html#CompAero.NormalShockRelations.NormalShockRelations.po2_po1">po2_po1</a></code></li>
<li><code><a title="CompAero.NormalShockRelations.NormalShockRelations.precision" href="NormalShockRelations.html#CompAero.NormalShockRelations.NormalShockRelations.precision">precision</a></code></li>
<li><code><a title="CompAero.NormalShockRelations.NormalShockRelations.rho2_rho1" href="NormalShockRelations.html#CompAero.NormalShockRelations.NormalShockRelations.rho2_rho1">rho2_rho1</a></code></li>
<li><code><a title="CompAero.NormalShockRelations.NormalShockRelations.t2_t1" href="NormalShockRelations.html#CompAero.NormalShockRelations.NormalShockRelations.t2_t1">t2_t1</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="CompAero" href="index.html">CompAero</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="CompAero.ObliqueShockRelations.ObliqueShockRelations" href="#CompAero.ObliqueShockRelations.ObliqueShockRelations">ObliqueShockRelations</a></code></h4>
<ul class="">
<li><code><a title="CompAero.ObliqueShockRelations.ObliqueShockRelations.calc_beta_from_mach_mach_normal_ahead_shock" href="#CompAero.ObliqueShockRelations.ObliqueShockRelations.calc_beta_from_mach_mach_normal_ahead_shock">calc_beta_from_mach_mach_normal_ahead_shock</a></code></li>
<li><code><a title="CompAero.ObliqueShockRelations.ObliqueShockRelations.calc_beta_from_theta_beta_mach_strong" href="#CompAero.ObliqueShockRelations.ObliqueShockRelations.calc_beta_from_theta_beta_mach_strong">calc_beta_from_theta_beta_mach_strong</a></code></li>
<li><code><a title="CompAero.ObliqueShockRelations.ObliqueShockRelations.calc_beta_from_theta_beta_mach_weak" href="#CompAero.ObliqueShockRelations.ObliqueShockRelations.calc_beta_from_theta_beta_mach_weak">calc_beta_from_theta_beta_mach_weak</a></code></li>
<li><code><a title="CompAero.ObliqueShockRelations.ObliqueShockRelations.calc_mach_ahead_shock_from_mach_normal_ahead_shock" href="#CompAero.ObliqueShockRelations.ObliqueShockRelations.calc_mach_ahead_shock_from_mach_normal_ahead_shock">calc_mach_ahead_shock_from_mach_normal_ahead_shock</a></code></li>
<li><code><a title="CompAero.ObliqueShockRelations.ObliqueShockRelations.calc_mach_behind_shock" href="#CompAero.ObliqueShockRelations.ObliqueShockRelations.calc_mach_behind_shock">calc_mach_behind_shock</a></code></li>
<li><code><a title="CompAero.ObliqueShockRelations.ObliqueShockRelations.calc_mach_from_mach_wave_angle" href="#CompAero.ObliqueShockRelations.ObliqueShockRelations.calc_mach_from_mach_wave_angle">calc_mach_from_mach_wave_angle</a></code></li>
<li><code><a title="CompAero.ObliqueShockRelations.ObliqueShockRelations.calc_mach_from_theta_beta_mach" href="#CompAero.ObliqueShockRelations.ObliqueShockRelations.calc_mach_from_theta_beta_mach">calc_mach_from_theta_beta_mach</a></code></li>
<li><code><a title="CompAero.ObliqueShockRelations.ObliqueShockRelations.calc_mach_normal_ahead_shock" href="#CompAero.ObliqueShockRelations.ObliqueShockRelations.calc_mach_normal_ahead_shock">calc_mach_normal_ahead_shock</a></code></li>
<li><code><a title="CompAero.ObliqueShockRelations.ObliqueShockRelations.calc_mach_normal_behind_shock_from_mach_behind_shock" href="#CompAero.ObliqueShockRelations.ObliqueShockRelations.calc_mach_normal_behind_shock_from_mach_behind_shock">calc_mach_normal_behind_shock_from_mach_behind_shock</a></code></li>
<li><code><a title="CompAero.ObliqueShockRelations.ObliqueShockRelations.calc_mach_wave_angle" href="#CompAero.ObliqueShockRelations.ObliqueShockRelations.calc_mach_wave_angle">calc_mach_wave_angle</a></code></li>
<li><code><a title="CompAero.ObliqueShockRelations.ObliqueShockRelations.calc_max_flow_deflection_angle" href="#CompAero.ObliqueShockRelations.ObliqueShockRelations.calc_max_flow_deflection_angle">calc_max_flow_deflection_angle</a></code></li>
<li><code><a title="CompAero.ObliqueShockRelations.ObliqueShockRelations.calc_max_shock_angle" href="#CompAero.ObliqueShockRelations.ObliqueShockRelations.calc_max_shock_angle">calc_max_shock_angle</a></code></li>
<li><code><a title="CompAero.ObliqueShockRelations.ObliqueShockRelations.calc_theta_from_theta_beta_mach" href="#CompAero.ObliqueShockRelations.ObliqueShockRelations.calc_theta_from_theta_beta_mach">calc_theta_from_theta_beta_mach</a></code></li>
<li><code><a title="CompAero.ObliqueShockRelations.ObliqueShockRelations.machNorm1" href="#CompAero.ObliqueShockRelations.ObliqueShockRelations.machNorm1">machNorm1</a></code></li>
<li><code><a title="CompAero.ObliqueShockRelations.ObliqueShockRelations.machNorm2" href="#CompAero.ObliqueShockRelations.ObliqueShockRelations.machNorm2">machNorm2</a></code></li>
<li><code><a title="CompAero.ObliqueShockRelations.ObliqueShockRelations.plot_theta_beta_mach_chart" href="#CompAero.ObliqueShockRelations.ObliqueShockRelations.plot_theta_beta_mach_chart">plot_theta_beta_mach_chart</a></code></li>
<li><code><a title="CompAero.ObliqueShockRelations.ObliqueShockRelations.shockAngle" href="#CompAero.ObliqueShockRelations.ObliqueShockRelations.shockAngle">shockAngle</a></code></li>
<li><code><a title="CompAero.ObliqueShockRelations.ObliqueShockRelations.shockType" href="#CompAero.ObliqueShockRelations.ObliqueShockRelations.shockType">shockType</a></code></li>
<li><code><a title="CompAero.ObliqueShockRelations.ObliqueShockRelations.useDegrees" href="#CompAero.ObliqueShockRelations.ObliqueShockRelations.useDegrees">useDegrees</a></code></li>
<li><code><a title="CompAero.ObliqueShockRelations.ObliqueShockRelations.wedgeAngle" href="#CompAero.ObliqueShockRelations.ObliqueShockRelations.wedgeAngle">wedgeAngle</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>